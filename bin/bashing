#!/usr/bin/env bash
# ---------------------------------------------
# Artifact:     bashing/bashing
# Version:      0.2.2
# Date (UTC):   Fri, 09 Aug 2019 11:18:52 +0000
# Generated by: bashing 0.2.2
# ---------------------------------------------
export __BASHING_VERSION='0.2.2'
export __VERSION='0.2.2'
export __ARTIFACT_ID='bashing'
export __GROUP_ID='bashing'
BASHING_ROOT=$(cd "$(dirname "$0")" && pwd)
BASHING_VERSION="$__VERSION"
BASHING_PROJECT_FILE="bashing.project"
CWD=$(pwd)
PROJECT_ROOT=$(pwd)
SETTINGS_DIR="$HOME/.bashing"
SETTINGS="$SETTINGS_DIR/config"
case "$1" in
    compile|uberbash|run|install|clean|new.*)
        while [ -d "$PROJECT_ROOT" ]; do
            if [ -e "$PROJECT_ROOT/$BASHING_PROJECT_FILE" ]; then break; fi
            PROJECT_ROOT="$PROJECT_ROOT/.."
        done
        if [ ! -d "$PROJECT_ROOT" ]; then
            echo "Could not find Root Directory of this Project!" 1>&2
            exit 1;
        fi
        PROJECT_ROOT=$(cd "$PROJECT_ROOT" && pwd);
    ;;
esac
RED="`tput setaf 1`"
GREEN="`tput setaf 2`"
YELLOW="`tput setaf 3`"
BLUE="`tput setaf 4`"
MAGENTA="`tput setaf 5`"
CYAN="`tput setaf 6`"
WHITE="`tput setaf 7`"
RESET="`tput sgr0`"
function colorize() {
    if [[ "$USE_COLORS" != "no" ]]; then
        c="$1"
        shift
        echo -n ${c}${@}${RESET};
    else
        shift
        echo -n "$@";
    fi
}
function green() { colorize "${GREEN}" "${@}"; }
function red() { colorize "${RED}" "${@}"; }
function yellow() { colorize "${YELLOW}" "${@}"; }
function blue() { colorize "${BLUE}" "${@}"; }
function magenta() { colorize "${MAGENTA}" "${@}"; }
function cyan() { colorize "${CYAN}" "${@}"; }
function white() { colorize "${WHITE}" "${@}"; }
function generateHeader() {
    print_out "#!/usr/bin/env bash"
    sep
    print_out "# $(head -c 45 /dev/zero | tr '\0' '-')";
    print_out "# Artifact:     $GROUP_ID/$ARTIFACT_ID"
    print_out "# Version:      $ARTIFACT_VERSION"
    print_out "# Date (UTC):   $(date -u -R 2> /dev/null || date -u +"%a, %d %h %Y %H:%M:%S %z" 2> /dev/null || date -u)"
    print_out "# Generated by: bashing $BASHING_VERSION"
    print_out "# $(head -c 45 /dev/zero | tr '\0' '-')";
    sep
}
function generateMetadata() {
    print_out "export __BASHING_VERSION='$BASHING_VERSION'"
    print_out "export __VERSION='$ARTIFACT_VERSION'"
    print_out "export __ARTIFACT_ID='$ARTIFACT_ID'"
    print_out "export __GROUP_ID='$GROUP_ID'"
    sep
}
function genInclude() {
    if [ -s "$SRC_PATH/$1" ]; then
        cd "$SRC_PATH"
        debug "Including File    ./$1 ..."
        includeBashFileIndent "./$1" "$2" | redirect_out
        sep
        cd "$CWD"
    fi
}
function includeLibFile() {
    local path=""
    while read -r path; do
        local fullPath=$(cd "$SRC_PATH/$(dirname "$path")" && pwd)/$(basename "$path");
        if bash -n "$fullPath" 1> /dev/null; then
            debug "Including Library $path ..."
            includeBashFile "$path" | redirect_out
            nl
        else
            return 1;
        fi
    done
    return 0
}
function generateLibrary() {
    comment "Library"
    nl
    cd "$SRC_PATH";
    find "./lib" -type f -name "*.sh" | sort | includeLibFile
    if [[ "$?" != "0" ]]; then exit 1; fi
    sep
    cd "$CWD";
}
function collectCliScripts() {
    if [ -d "$CLI_PATH" ]; then
        cd "$CLI_PATH"
        find "." -type f -name "*.sh" -not -size 0 | sort
        cd "$CWD"
    fi
    if [ -d "$HID_PATH" ]; then
        cd "$HID_PATH"
        find "." -type f -name "*.sh" -not -size 0 | sort
        cd "$CWD"
    fi
}
function toFn() {
    local n="$1"
    echo "cli_${n:2:${#n}-5}" | tr '/' '_' | sed 's/_+/_/g'
}
function toCliArg() {
    local n="$1"
    echo "${n:2:${#n}-5}" | tr '/' '.'
}
function includeCliFn() {
    local path="$1"
    local fnName=$(toFn "$path");
    local fullPath="$CLI_PATH/$path"
    local hidden="no"
    if [ -e "$fullPath" ] && [ -e "$HID_PATH/$path" ]; then
        fatal "Task and hidden Task of the same name: $path"
    else if [ -e "$HID_PATH/$path" ]; then
        local fullPath="$HID_PATH/$path";
        local hidden="yes"
    fi; fi
    if [[ "$fnName" == "cli_help" ]] && [[ "$BUILD_HELP" == "yes" ]]; then
        echo "WARN: CLI Function 'help' ($fullPath) overwrite built-in help." 1>&2;
        echo "WARN: Supply '--no-help' if you want to create your own help function." 1>&2;
    fi
    if bash -n "$fullPath" 1> /dev/null; then
        if [[ "$hidden" == "no" ]]; then debug "Including Task    $path -> $fnName ..."; comment "./tasks/${path:2}";
        else debug "Including Task    $path -> $fnName (hidden) ..."; comment "./hidden-tasks/${path:2}"; fi
        print_out "function ${fnName}() {"
        includeBashFileIndent "$fullPath" "  " | redirect_out
        print_out '  return 0;'
        print_out "}"
        return 0;
    fi
    return 1;
}
function buildCliHandler() {
    local path="$1"
    local fnName=$(toFn "$path")
    local argName=$(toCliArg "$path")
    print_out "    \"$argName\") ($fnName \"\$@\"); status=\$?;;"
}
function buildCliHeader() {
    print_out "function __run() {"
    print_out '  local status=255'
    genInclude "before-task.sh" "  "
    print_out '  local cmd="${1-}"'
    print_out '  shift || true'
    print_out '  case "$cmd" in'
    print_out '    "") __run "help"; return $?;;'
}
function buildCliFooter() {
    print_out '    *) echo "Unknown Command: $cmd" 1>&2;;'
    print_out '  esac'
    genInclude "after-task.sh" "  "
    print_out '  return $status'
    print_out "}"
}
function buildHelpTable() {
    local hlp="yes"
    local vrs="yes"
    for path in $@; do
        if [ -e "$CLI_PATH/$path" ]; then
            local argName=$(toCliArg "$path");
            local helpText=$(getMeta "$CLI_PATH/$path" "help")
            if [ -z "$helpText" ]; then helpText="(no help available)"; fi
            echo "$argName|:|$helpText"
            case "$argName" in
                "help") local hlp="no";;
                "version") local vrs="no";;
            esac
        fi
    done
    if [ "$hlp" == "yes" ]; then echo "help|:|display this help message"; fi
    if [ "$vrs" == "yes" ]; then echo "version|:|display version"; fi
}
function buildHelpFunction() {
    print_out '    "help")'
    print_out "      echo \"Usage: $ARTIFACT_ID <task> [...]\" 1>&2"
    print_out '      cat 1>&2 <<HELP'
    print_out ''
    buildHelpTable "$@" | column -s "|" -t\
        | sort\
        | sed 's/^/    /'\
        | redirect_out
    print_out ''
    print_out 'HELP'
    print_out '      status=0'
    print_out '      ;;'
}
function buildVersionFunction() {
    print_out '    "version")'
    print_out "      echo \"$ARTIFACT_ID $ARTIFACT_VERSION (bash \$BASH_VERSION)\""
    print_out '      status=0'
    print_out '      ;;'
}
function generateCli() {
    cliScripts=$(collectCliScripts);
    set -e
    comment "CLI Functions"
    nl
    for path in $cliScripts; do includeCliFn "$path"; done
    sep
    comment "Main Function"
    nl
    buildCliHeader
    for path in $cliScripts; do buildCliHandler "$path"; done
    if [[ "$BUILD_HELP" == "yes" ]]; then buildHelpFunction "$cliScripts"; fi
    buildVersionFunction
    buildCliFooter
    if [ -e "$SRC_PATH/main.sh" ]; then
        genInclude "main.sh";
    else
        print_out "__run \"\$@\""
    fi;
    print_out 'export __STATUS="$?"'
    sep
    cd "$CWD";
}
function generateCliExit() {
    print_out 'exit $__STATUS'
}
function generateStandaloneTask() {
    local task="$1"
    COMPACT="yes"
    OUT=""
    DEBUG="no"
    VERBOSE="no"
    generateHeader
    generateMetadata
    genInclude "init.sh"
    generateLibrary
    genInclude "before-task.sh"
    print_out 'shift || true'
    print_out 'function __run() { echo "__run not available when running CLI task directly!" 1>&2; exit 1; }'
    if [ -e "$CLI_PATH/$task" ]; then genInclude "tasks/$task";
    else genInclude "hidden-tasks/$task"; fi
    genInclude "after-task.sh"
    genInclude "cleanup.sh"
}
function print_out() {
    if [ -z "$OUT" ]; then
        echo "$@";
    else
        echo "$@" >> "$OUT"
    fi
}
function redirect_out() {
    local line=""
    while IFS='' read -r line; do
        print_out "$line";
    done
}
function sep() { 
    if [[ "$COMPACT" != "yes" ]]; then
        print_out -n "# ";  
        print_out "$(head -c 45 /dev/zero | tr '\0' '-')"; 
    fi
}
function comment() { 
    if [[ "$COMPACT" != "yes" ]]; then print_out "# $@"; fi; 
}
function nl() { 
    if [[ "$COMPACT" != "yes" ]]; then print_out ""; fi; 
}
function includeBashFile() {
    if [ -s "$1" ] && bash -n "$1"; then
        local plain=$(getMeta "$1" "plain")
        if [[ "$plain" == "true" ]]; then
            cat "$1";
        else if [[ "$COMPACT" == "yes" ]]; then
            sed '/^\s*#.*$/d' "$1" | sed '/^\s*$/d';
        else
            echo "# $1";
            sed '/^\s*#.*$/d' "$1";
        fi; fi;
    fi
}
function includeBashFileIndent() {
    local indent="$2"
    local plain=$(getMeta "$1" "plain")
    if [[ "$plain" == "true" ]]; then
        cat "$1";
    else 
        includeBashFile "$1" | sed "s/^/$indent/"
    fi
}
function debugBash() {
    sed 's/^function\s\+\([^\s]\+\)()/\
            function \1() {\
                local ind="$___INDENT";\
                printf "${ind}> enter:\1 %q\n" "$*" 1>\&2;\
                export ___INDENT="$___INDENT  ";\
                debugging___\1 "$@";\
                export ___INDENT="$ind";\
                local st="$?";\
                printf "${ind}< leave:\1 %q\n" "$*" 1>\&2;\
                return $st;\
            }\
            function debugging___\1()/' -;
}
function error() {
    echo -n "$(red "(ERROR)") " 1>&2
    echo "$@" 1>&2
}
function fatal() {
    error "$@";
    exit 1;
}
function success() {
    echo "$(green "$@")"
}
function verbose() {
    if [[ "$VERBOSE" != "no" ]] || [ -z "$VERBOSE" ]; then
        echo "$@"
    fi
}
function debug() {
    if [[ "$DEBUG" == "yes" ]]; then
        echo -n "$(yellow "(DEBUG)  ")";
        echo "$@";
    fi
}
function getMeta() {
    local path="$1"
    local key="$2"
    if  [ ! -s "$1" ]; then return 1; fi
    sed '/^\s*$/d' "$path"\
        | sed '/^\s*\([^#]\|#!\)/d'\
        | sed 's/^\s*# \?//'\
        | sed -n "/<$key>/,\$p"\
        | sed -n "0,/<\/$key>/p"\
        | sed "s/<\/\?$key>//g"
}
RX_ID='[a-zA-Z][a-zA-Z0-9_-]*'
RX_INT='\(0\|[1-9][0-9]*\)'
RX_VERSION="$RX_INT\\.$RX_INT\\.$RX_INT\(-$RX_ID\\)\\?"
RX_ARTIFACT_STRING="^\\s*\\(\\($RX_ID\\)\\/\\)\\?\\($RX_ID\\)\\s\\+\\($RX_VERSION\\)\\s*$"
function artifactString() { head -n 1 "$PROJECT_FILE"; }
function artifactGet() { echo "$1" | sed -n "s/$RX_ARTIFACT_STRING/\\$2/p"; }
function artifactVersion() { artifactGet "$1" 4; }
function artifactId() { artifactGet "$1" 3; }
function artifactGroupId() { artifactGet "$1" 2; }
__SED_PATH="$(which sed)"
function check_sed() {
    local GSED=$(which gsed 2> /dev/null)
    if [ ! -z "$GSED" ]; then
        __SED_PATH="$GSED"
        return 0;
    fi
    $__SED_PATH --version >& /dev/null
    if [ ! $? -eq 0 ]; then
        fatal "Needs GNU's 'sed' to be installed."
        return 1
    fi
    return 0
}
function sed() {
    $__SED_PATH "$@"
}
function check_tools() {
    check_sed
}
function cli_clean() {
  rm -rf "$PROJECT_ROOT/target"
  return 0;
}
function cli_install() {
  __run "deploy" "$HOME/.bin"
  return 0;
}
function cli_new() {
  ARTIFACT="$1"
  INIT_PATH="$2"
  if [ -z "$ARTIFACT" ]; then
      error "Usage: new <Artifact ID> [<Path>]"
      exit 1;
  fi
  if [ -z "$INIT_PATH" ]; then INIT_PATH="./$ARTIFACT"; fi
  if [ -d "$INIT_PATH" ]; then
      error "$INIT_PATH already exists.";
      exit 1;
  fi
  SRC="$INIT_PATH/src"
  TASKS="$SRC/tasks"
  LIB="$SRC/lib"
  HIDDEN="$SRC/hidden-tasks"
  PROJ="$INIT_PATH/bashing.project"
  echo "Initializing $INIT_PATH ..."
  for dir in "$TASKS" "$LIB" "$HIDDEN"; do
      if ! mkdir -p "$dir"; then fatal "Could not create Directory: $dir"; fi
  done
  if ! touch "$INIT_PATH/.gitignore"; then fatal "Could not create '.gitignore'."; fi
  for txt in "target/" "*.swp" "*~"; do
      echo "$txt" >> "$INIT_PATH/.gitignore"
  done
  if ! touch "$PROJ"; then fatal "Could not create File: $PROJ"; fi
  echo "$ARTIFACT 0.1.0-SNAPSHOT" >> "$PROJ"
  echo "" >> "$PROJ"
  echo "YOUR DESCRIPTION HERE." >> "$PROJ"
  path="$TASKS/hello.sh"
  if ! touch "$path"; then fatal "Could not create File: $path"; fi
  echo "#!/usr/bin/env bash" > "$path"
  echo "" >> "$path"
  echo "# Run with: 'bashing run hello'" >> "$path"
  echo "" >> "$path" >> "$path"
  echo "echo \"Hello, World!\"" >> "$path"
  success "Successfully initialized '$INIT_PATH'."
  exit 0
  return 0;
}
function cli_remote() {
  subtask="$1"
  if [ -z "$subtask" ]; then fatal "Usage: remote [[add|install] <name> <git repository> | remove <name>]"; fi
  shift
  __run "remote.$subtask" "$@"
  return 0;
}
function cli_run() {
  CLI="$1"
  if [ -z "$CLI" ]; then
      error "Usage: run <CLI Command> <Parameters>"
      exit 1;
  fi
  SRC="$(echo "$CLI" | tr '.' '/').sh"
  path="$CLI_PATH/$SRC"
  if [ ! -e "$path" -a -e "$HID_PATH/$SRC" ]; then path="$HID_PATH/$SRC"; fi
  if [ ! -e "$path" ]; then fatal "No such Task: $CLI"; fi
  generateStandaloneTask "$SRC" | bash -s "$@" &
  wait "$!"
  st="$?"
  debug "Task exitted with status $st."
  exit "$st"
  return 0;
}
function cli_uberbash() {
  TARGET_PATH="$PROJECT_ROOT/target"
  TARGET_FILE="$TARGET_PATH/$ARTIFACT_ID-$ARTIFACT_VERSION.sh"
  TARGET_FILE_COMPRESSED="$TARGET_PATH/$ARTIFACT_ID-$ARTIFACT_VERSION.gz.sh"
  TARGET_FILE_DEBUG="$TARGET_PATH/$ARTIFACT_ID-$ARTIFACT_VERSION.debug.sh"
  COMPRESS="no"
  DEBUGGABLE="no"
  if ! mkdir -p "$TARGET_PATH" 2> /dev/null; then
      error "Could not create target directory: $TARGET_PATH";
      exit 1;
  fi
  while [ $# -gt 0 ]; do
      case "$1" in
          "--compress") COMPRESS="yes";;
          "--with-debug") DEBUGGABLE="yes";;
          *) ;;
      esac
      shift
  done
  verbose "Creating $TARGET_FILE ..."
  __run "compile" "--compact" -o "$TARGET_FILE"
  if [[ "$?" != "0" ]]; then fatal "An error occured while running task 'compile'."; fi
  success "Uberbash created successfully."
  chmod +x "$TARGET_FILE" >& /dev/null
  if [[ "$DEBUGGABLE" == "yes" ]]; then
      echo "Creating $TARGET_FILE_DEBUG ..."
      cat "$TARGET_FILE" | debugBash > "$TARGET_FILE_DEBUG"
      if [[ "$?" != "0" ]]; then fatal "An error occured while running task 'compile'."; fi
      success "Uberbash (debuggable) created successfully."
      chmod +x "$TARGET_FILE_DEBUG" >& /dev/null
  fi
  if [[ "$COMPRESS" == "yes" ]]; then
      verbose "Compressing into $TARGET_FILE_COMPRESSED ..."
      echo "#!/usr/bin/env bash" > "$TARGET_FILE_COMPRESSED"
      echo 'tail -n +3 "$0" | gzip -d -n 2> /dev/null | bash -s "$@"; exit $?' >> "$TARGET_FILE_COMPRESSED"
      gzip -c -n "$TARGET_FILE" >> "$TARGET_FILE_COMPRESSED";
      if [[ "$?" != "0" ]]; then fatal "An error occured while running task 'compile'."; fi
      success "Uberbash (compressed) created successfully."
      chmod +x "$TARGET_FILE_COMPRESSED" >& /dev/null
  fi
  exit 0
  return 0;
}
function cli_version() {
  echo "bashing $(yellow "$__VERSION") (bash $BASH_VERSION)"
  return 0;
}
function cli_compile() {
  BUILD_HEADER="yes"
  BUILD_METADATA="yes"
  BUILD_LIBRARY="yes"
  BUILD_CLI="yes"
  BUILD_HELP="yes"
  COMPACT="no"
  OUTPUT_FILE=""
  while [ $# -gt 0 ]; do
      arg="$1"
      case "$arg" in
          "--out"|"-o") shift; OUTPUT_FILE="$1";;
          "--compact") COMPACT="yes";;
          "--no-metadata") BUILD_METADATA="no";;
          "--no-lib") BUILD_LIBRARY="no";;
          "--no-cli") BUILD_CLI="no";;
          "--no-header") BUILD_HEADER="no";;
          --*)
              error "Invalid command line argument: $arg"
              exit 1
              ;;
          *)
              if [ -z "$PROJECT_ROOT" ]; then PROJECT_ROOT="$arg";
              else error "Invalid command line argument: $arg"; exit 1; fi
              ;;
      esac
      shift
  done
  if [ ! -z "$OUTPUT_FILE" ]; then
      OUTPUT_FILE="$(cd $(dirname "$OUTPUT_FILE") && pwd)/$(basename "$OUTPUT_FILE")"
      rm -f "$OUTPUT_FILE"
      if ! touch "$OUTPUT_FILE" 2> /dev/null; then
          error "Cannot write to given Output File: $OUTPUT_FILE.";
          exit 1;
      fi
      export OUT="$OUTPUT_FILE"
  fi
  cd "$SRC_PATH"
  if [[ "$BUILD_HEADER" == "yes" ]]; then generateHeader; fi
  if [[ "$BUILD_METADATA" == "yes" ]]; then generateMetadata; fi
  genInclude "init.sh"
  if [[ "$BUILD_LIBRARY" == "yes" ]] && [ -d "$LIB_PATH" ]; then generateLibrary; fi
  if [[ "$BUILD_CLI" == "yes" ]]; then generateCli; fi
  genInclude "cleanup.sh"
  if [[ "$BUILD_CLI" == "yes" ]]; then generateCliExit; fi
  cd "$CWD"
  return 0;
}
function cli_deploy() {
  path="$1"
  if [ -z "$path" ]; then path="$PROJECT_ROOT/bin"; fi
  set -e
  __run "uberbash"
  src="$PROJECT_ROOT/target/$ARTIFACT_ID-$ARTIFACT_VERSION.sh"
  if [ ! -s "$src" ]; then fatal "Could not find Uberbash."; fi
  dst="$path/$ARTIFACT_ID"
  if ! mkdir -p "$path"; then fatal "Could not create $path."; fi
  verbose "Deploying to $dst ..."
  cp "$src" "$dst" 2> /dev/null || fatal "Could not copy $src to $dst ...";
  success "Deployed successfully."
  return 0;
}
function cli_new_task() {
  task="$1"
  hidden="no"
  if [ "$task" == "--hidden" ]; then task="$2"; hidden="yes"; fi
  if [ -z "$task" ]; then fatal "Usage: new.task [--hidden] <Task>"; fi
  file="$(echo "$task" | tr '.' '/').sh"
  if [ "$hidden" == "yes" ]; then path="$HID_PATH/$file";
  else path="$CLI_PATH/$file"; fi
  dir="$(dirname "$path")"
  if ! mkdir -p "$dir"; then fatal "Could not create Directory: $dir"; fi
  if [ -e "$path" ]; then fatal "File does already exist: $path"; fi
  if ! touch "$path"; then fatal "Could not create File: $path"; fi
  echo "#!/usr/bin/env bash" > "$path"
  echo "" >> "$path"
  echo "# Run with: 'bashing run $task'" >> "$path"
  echo "" >> "$path" >> "$path"
  echo "echo \"Hello from Task '$task'\"" >> "$path"
  success "Created Task '$task'."
  return 0;
}
function cli_remote_add() {
  name="$1"
  repo="$2"
  set -e
  if [ -z "$name" -o -z "$repo" ]; then fatal "Usage: remote add <name> <git repository>"; fi
  if [ -e "$SETTINGS" ] && grep -q "^repo:$name=" "$SETTINGS"; then fatal "Remote Application already in $SETTINGS: $name"; fi 
  echo "repo:$name=$repo" >> "$SETTINGS"
  success "Added Application: $name"
  return 0;
}
function cli_remote_install() {
  name="$1"
  repo="$2"
  set -e
  if [ -z "$name" ]; then fatal "Usage: remote install <name> [<git repository>]"; fi
  if [ -z "$repo" ]; then repo=$(grep "^repo:$name=" "$SETTINGS" 2> /dev/null | sed "s/^repo:$name=//" | head -n 1); fi
  if [ -z "$repo" ]; then fatal "Cannot resolve Remote Application: $name"; fi
  REPO_DIR="$SETTINGS_DIR/remote"
  mkdir -p "$REPO_DIR" 2> /dev/null || fatal "Could not initialize Remote Application Cache: $REPO_DIR"
  APP="$REPO_DIR/$name"
  which git >& /dev/null || fatal "Missing dependency: git"
  verbose "Fetching bashing Project ($APP) ..."
  if [ -d "$APP" ]; then
      cd "$APP";
      git pull
  else 
      git clone "$repo" "$APP"
      cd "$APP"
  fi
  if [ ! -e "$APP/$BASHING_PROJECT_FILE" ]; then fatal "Not a bashing project at: $APP"; fi
  PROJECT_ROOT="$APP"
  __run "install"
  return 0;
}
function cli_remote_remove() {
  name="$1"
  if [ -z "$name" ]; then fatal "Usage: remote remove <name>"; fi
  if [ -e "$SETTINGS" ]; then
      sed -i "/^repo:$name=/d" "$SETTINGS"
      if [ "$?" != "0" ]; then fatal "Could not modify $SETTINGS correctly."; fi
  fi
  success "Removed Application: $name"
  return 0;
}
function __run() {
  local status=255
  check_tools
  mkdir -p "$SETTINGS_DIR" 2> /dev/null || fatal "Could not initialize directory: $SETTINGS_DIR";
  PROJECT_FILE="$PROJECT_ROOT/$BASHING_PROJECT_FILE"
  SRC_PATH="$PROJECT_ROOT/src"
  CLI_PATH="$SRC_PATH/tasks"
  LIB_PATH="$SRC_PATH/lib"
  HID_PATH="$SRC_PATH/hidden-tasks"
  GROUP_ID=""
  ARTIFACT_ID=""
  ARTIFACT_VERSION=""
  while [ $# -gt 0 ]; do
      case "$1" in
          "--debug")
              DEBUG="yes"
              shift
              ;;
          "compile"|"uberbash"|"run"|"deploy"|"install")
              s=$(artifactString)
              GROUP_ID=$(artifactGroupId "$s")
              ARTIFACT_ID=$(artifactId "$s")
              ARTIFACT_VERSION=$(artifactVersion "$s")
              if [ -z "$ARTIFACT_ID" -o -z "$ARTIFACT_VERSION" ]; then
                  error "Invalid Artifact String in $BASHING_PROJECT_FILE: $s";
                  exit 1;
              fi
              if [ -z "$GROUP_ID" ]; then GROUP_ID="$ARTIFACT_ID"; fi
              debug "Artifact: $ARTIFACT_ID"
              debug "Group ID: $GROUP_ID"
              debug "Version:  $ARTIFACT_VERSION"
              debug "Root:     $PROJECT_ROOT"
              break;;
          *) break;;
      esac
  done
  local cmd="${1-}"
  shift || true
  case "$cmd" in
    "") __run "help"; return $?;;
    "clean") (cli_clean "$@"); status=$?;;
    "install") (cli_install "$@"); status=$?;;
    "new") (cli_new "$@"); status=$?;;
    "remote") (cli_remote "$@"); status=$?;;
    "run") (cli_run "$@"); status=$?;;
    "uberbash") (cli_uberbash "$@"); status=$?;;
    "version") (cli_version "$@"); status=$?;;
    "compile") (cli_compile "$@"); status=$?;;
    "deploy") (cli_deploy "$@"); status=$?;;
    "new.task") (cli_new_task "$@"); status=$?;;
    "remote.add") (cli_remote_add "$@"); status=$?;;
    "remote.install") (cli_remote_install "$@"); status=$?;;
    "remote.remove") (cli_remote_remove "$@"); status=$?;;
    "help")
      echo "Usage: bashing <task> [...]" 1>&2
      cat 1>&2 <<HELP

    clean     :  remove build results and cached data
    help      :  display this help message
    install   :  deploy uberbash at $HOME/.bin
    new       :  initialize directories for a bashing project
    remote    :  handle remote bashing applications
    run       :  run task in the project's context
    uberbash  :  create standalone bash script
    version   :  display version

HELP
      status=0
      ;;
    "version")
      echo "bashing 0.2.2 (bash $BASH_VERSION)"
      status=0
      ;;
    *) echo "Unknown Command: $cmd" 1>&2;;
  esac
  return $status
}
__run "$@"
export __STATUS="$?"
exit $__STATUS
